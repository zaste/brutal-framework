<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CompanyCity Enhanced - BRUTAL V6</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            color: #fff; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
            position: relative;
        }
        
        canvas { 
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Enhanced UI with glass morphism */
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        .panel {
            position: absolute;
            background: rgba(15, 15, 25, 0.75);
            backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(139, 92, 246, 0.15);
            border-radius: 16px;
            padding: 20px;
            pointer-events: auto;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 0 80px rgba(139, 92, 246, 0.1) inset;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .panel:hover {
            border-color: rgba(139, 92, 246, 0.3);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 0 120px rgba(139, 92, 246, 0.15) inset;
        }
        
        /* Mode selector with enhanced styling */
        #mode-selector {
            top: 30px;
            left: 30px;
            display: flex;
            gap: 2px;
            padding: 4px;
            background: rgba(10, 10, 20, 0.9);
        }
        
        .mode-btn {
            position: relative;
            padding: 14px 28px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 1.5px;
            overflow: hidden;
        }
        
        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, transparent, rgba(139, 92, 246, 0.1));
            transform: translateX(-100%);
            transition: transform 0.3s;
        }
        
        .mode-btn:hover {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .mode-btn:hover::before {
            transform: translateX(0);
        }
        
        .mode-btn.active {
            color: #fff;
            background: linear-gradient(135deg, #8b5cf6, #6d42d8);
            text-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
        }
        
        /* Performance monitor */
        #performance {
            top: 30px;
            right: 30px;
            min-width: 240px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            background: rgba(10, 10, 20, 0.9);
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .stat-label {
            color: rgba(255, 255, 255, 0.5);
            font-weight: 500;
        }
        
        .stat-value {
            color: #00ff88;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .stat-bar {
            width: 100%;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 4px;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc70);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        /* Enhanced inspector */
        #inspector {
            right: 30px;
            bottom: 30px;
            width: 360px;
            max-height: 480px;
            opacity: 0;
            transform: translateX(100%) scale(0.95);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(10, 10, 20, 0.95);
        }
        
        #inspector.visible {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
        
        #inspector-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #fff, #e0e0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .inspector-section {
            margin: 16px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .inspector-label {
            color: rgba(255, 255, 255, 0.5);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }
        
        .inspector-value {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
        }
        
        /* Loading screen */
        .loading-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #000;
            z-index: 1000;
        }
        
        .loading-logo {
            font-size: 72px;
            font-weight: 900;
            letter-spacing: -4px;
            background: linear-gradient(135deg, #8b5cf6, #00ff88, #ff0080);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 2s ease-in-out infinite;
            margin-bottom: 24px;
        }
        
        .loading-text {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .loading-bar {
            width: 200px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 24px;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .loading-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6, #00ff88);
            width: 0%;
            animation: loadProgress 3s ease-out forwards;
        }
        
        @keyframes glow {
            0%, 100% { 
                filter: brightness(1) drop-shadow(0 0 20px rgba(139, 92, 246, 0.5)); 
            }
            50% { 
                filter: brightness(1.2) drop-shadow(0 0 40px rgba(139, 92, 246, 0.8)); 
            }
        }
        
        @keyframes loadProgress {
            to { width: 100%; }
        }
        
        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.2s;
            z-index: 200;
            font-size: 13px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="loading-container" id="loading">
        <div class="loading-logo">COMPANYCITY</div>
        <div class="loading-text">Initializing Neural Network</div>
        <div class="loading-bar">
            <div class="loading-bar-fill"></div>
        </div>
    </div>
    
    <canvas id="canvas"></canvas>
    <canvas id="effectCanvas"></canvas>
    
    <div id="ui">
        <div class="panel" id="mode-selector">
            <button class="mode-btn active" data-mode="explorer">Explorer</button>
            <button class="mode-btn" data-mode="architect">Architect</button>
            <button class="mode-btn" data-mode="matrix">Matrix</button>
            <button class="mode-btn" data-mode="neural">Neural</button>
        </div>
        
        <div class="panel" id="performance">
            <div class="stat">
                <span class="stat-label">FPS</span>
                <span class="stat-value" id="fps">60</span>
            </div>
            <div class="stat-bar">
                <div class="stat-bar-fill" id="fps-bar" style="width: 100%"></div>
            </div>
            
            <div class="stat">
                <span class="stat-label">Objects</span>
                <span class="stat-value" id="objects">0</span>
            </div>
            
            <div class="stat">
                <span class="stat-label">Particles</span>
                <span class="stat-value" id="particles">0</span>
            </div>
            
            <div class="stat">
                <span class="stat-label">Draw Calls</span>
                <span class="stat-value" id="drawCalls">0</span>
            </div>
        </div>
        
        <div class="panel" id="inspector">
            <h3 id="inspector-title">System Information</h3>
            <div id="inspector-content">
                <div class="inspector-section">
                    <div class="inspector-label">Type</div>
                    <div class="inspector-value" id="inspector-type">-</div>
                </div>
                <div class="inspector-section">
                    <div class="inspector-label">Status</div>
                    <div class="inspector-value" id="inspector-status">-</div>
                </div>
                <div class="inspector-section">
                    <div class="inspector-label">Connections</div>
                    <div class="inspector-value" id="inspector-connections">-</div>
                </div>
            </div>
        </div>
        
        <div class="tooltip" id="tooltip"></div>
    </div>
    
    <!-- BRUTAL V6 Enhanced Implementation -->
    <script type="module">
        // Import Three.js and post-processing
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/ShaderPass.js';
        
        // BRUTAL Core - Enhanced Composition Pattern
        const compose = (...behaviors) => (element) => {
            const composed = behaviors.reduce((el, behavior) => behavior(el), element);
            composed._behaviors = behaviors;
            return composed;
        };
        
        // Enhanced State Management with Deep Reactivity
        const withState = (initial) => (component) => {
            const handlers = new Map();
            const state = new Proxy(initial, {
                set(target, prop, value) {
                    const oldValue = target[prop];
                    target[prop] = value;
                    
                    // Trigger specific handlers
                    if (handlers.has(prop)) {
                        handlers.get(prop).forEach(handler => handler(value, oldValue));
                    }
                    
                    // Trigger render if needed
                    if (component.render && component._autoRender !== false) {
                        requestAnimationFrame(() => component.render());
                    }
                    
                    return true;
                },
                get(target, prop) {
                    if (prop === '_watch') {
                        return (key, handler) => {
                            if (!handlers.has(key)) handlers.set(key, new Set());
                            handlers.get(key).add(handler);
                            return () => handlers.get(key).delete(handler);
                        };
                    }
                    return target[prop];
                }
            });
            
            component.state = state;
            return component;
        };
        
        // Enhanced Event System with Delegation
        const withEvents = (eventMap) => (component) => {
            const eventBus = new EventTarget();
            
            // Enhanced event handling
            Object.entries(eventMap).forEach(([event, handler]) => {
                if (event.includes(':')) {
                    // Custom event
                    const [eventName, selector] = event.split(':');
                    component.addEventListener(eventName, (e) => {
                        if (!selector || e.target.matches(selector)) {
                            handler.call(component, e);
                        }
                    });
                } else {
                    // Regular event
                    component.addEventListener(event, handler.bind(component));
                }
            });
            
            // Add event emission
            component.emit = (event, detail) => {
                const customEvent = new CustomEvent(event, { detail, bubbles: true });
                component.dispatchEvent(customEvent);
                eventBus.dispatchEvent(customEvent);
            };
            
            component.on = (event, handler) => {
                eventBus.addEventListener(event, handler);
                return () => eventBus.removeEventListener(event, handler);
            };
            
            return component;
        };
        
        // Performance monitoring behavior
        const withPerformance = (component) => {
            let lastTime = performance.now();
            let frames = 0;
            let fps = 60;
            
            const measureFPS = () => {
                frames++;
                const currentTime = performance.now();
                if (currentTime >= lastTime + 1000) {
                    fps = Math.round((frames * 1000) / (currentTime - lastTime));
                    frames = 0;
                    lastTime = currentTime;
                    
                    // Update UI
                    document.getElementById('fps').textContent = fps;
                    document.getElementById('fps-bar').style.width = `${(fps / 60) * 100}%`;
                }
                requestAnimationFrame(measureFPS);
            };
            
            measureFPS();
            component.getFPS = () => fps;
            return component;
        };
        
        // Advanced shader composition
        const createShaderMaterial = (uniforms, vertexShader, fragmentShader) => {
            return new THREE.ShaderMaterial({
                uniforms,
                vertexShader,
                fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
        };
        
        // Glow shader for buildings
        const glowVertexShader = `
            varying vec3 vNormal;
            varying vec3 vPositionNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPositionNormal = normalize((modelViewMatrix * vec4(position, 1.0)).xyz);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        const glowFragmentShader = `
            uniform vec3 glowColor;
            uniform float intensity;
            uniform float fade;
            varying vec3 vNormal;
            varying vec3 vPositionNormal;
            
            void main() {
                float a = pow(abs(dot(vNormal, vPositionNormal)), fade);
                gl_FragColor = vec4(glowColor, a) * intensity;
            }
        `;
        
        // Connection flow shader
        const flowVertexShader = `
            attribute float offset;
            uniform float time;
            varying float vAlpha;
            
            void main() {
                vec3 pos = position;
                float flow = fract(offset + time * 0.5);
                pos.y += sin(flow * 3.14159) * 2.0;
                vAlpha = sin(flow * 3.14159);
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = 3.0 * vAlpha;
            }
        `;
        
        const flowFragmentShader = `
            uniform vec3 color;
            varying float vAlpha;
            
            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                if(length(coord) > 0.5) discard;
                
                gl_FragColor = vec4(color, vAlpha * 0.8);
            }
        `;
        
        // Main Scene Component with Full Visual Fidelity
        class EnhancedSceneComponent extends HTMLElement {
            constructor() {
                super();
                this.attachShadow({ mode: 'open' });
            }
            
            connectedCallback() {
                this.initialize();
            }
            
            async initialize() {
                // Apply BRUTAL composition
                compose(
                    withState({
                        mode: 'explorer',
                        districts: this.getFullDistrictsData(),
                        selected: null,
                        connections: [],
                        particles: {
                            ambient: 500,
                            flow: 1000,
                            neural: 2000
                        },
                        stats: {
                            fps: 60,
                            objects: 0,
                            particles: 0,
                            drawCalls: 0
                        }
                    }),
                    withEvents({
                        'mode-change': function(e) {
                            this.state.mode = e.detail;
                            this.applyMode();
                        },
                        'object-hover': function(e) {
                            this.handleHover(e.detail);
                        },
                        'object-select': function(e) {
                            this.state.selected = e.detail;
                            this.showInspector();
                        }
                    }),
                    withPerformance
                )(this);
                
                // Initialize enhanced scene
                this.setupEnhancedScene();
                this.buildEnhancedCity();
                this.setupPostProcessing();
                this.animate();
                
                // Hide loading after delay
                setTimeout(() => {
                    const loading = document.getElementById('loading');
                    loading.style.opacity = '0';
                    loading.style.pointerEvents = 'none';
                    setTimeout(() => loading.style.display = 'none', 500);
                }, 3000);
            }
            
            setupEnhancedScene() {
                const canvas = document.getElementById('canvas');
                
                // Scene with fog
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000510);
                this.scene.fog = new THREE.FogExp2(0x000510, 0.0008);
                
                // Camera with cinematic settings
                this.camera = new THREE.PerspectiveCamera(
                    35,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    2000
                );
                this.camera.position.set(180, 120, 180);
                this.camera.lookAt(0, 0, 0);
                
                // Renderer with high quality settings
                this.renderer = new THREE.WebGLRenderer({
                    canvas,
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                
                // Complex lighting setup
                this.setupAdvancedLighting();
                
                // Controls with smooth damping
                this.setupSmoothControls();
                
                // Raycaster for interactions
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
            }
            
            setupAdvancedLighting() {
                // Ambient light with color
                const ambient = new THREE.AmbientLight(0x1a1a3e, 0.4);
                this.scene.add(ambient);
                
                // Main directional light
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);
                mainLight.position.set(50, 100, 50);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 2048;
                mainLight.shadow.mapSize.height = 2048;
                mainLight.shadow.camera.near = 0.5;
                mainLight.shadow.camera.far = 500;
                mainLight.shadow.camera.left = -150;
                mainLight.shadow.camera.right = 150;
                mainLight.shadow.camera.top = 150;
                mainLight.shadow.camera.bottom = -150;
                this.scene.add(mainLight);
                
                // Rim lights for depth
                const rimLight1 = new THREE.DirectionalLight(0x8b5cf6, 0.3);
                rimLight1.position.set(-100, 50, -100);
                this.scene.add(rimLight1);
                
                const rimLight2 = new THREE.DirectionalLight(0x00ff88, 0.2);
                rimLight2.position.set(100, 50, 100);
                this.scene.add(rimLight2);
                
                // Point lights for districts
                this.districtLights = [];
            }
            
            setupSmoothControls() {
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };
                let targetRotation = { x: 0, y: 0 };
                let currentRotation = { x: 0, y: 0 };
                let targetZoom = 180;
                let currentZoom = 180;
                
                const canvas = this.renderer.domElement;
                
                // Mouse controls
                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });
                
                window.addEventListener('mousemove', (e) => {
                    // Update mouse position for raycasting
                    this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    
                    if (!isDragging) {
                        this.checkHover();
                        return;
                    }
                    
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };
                    
                    targetRotation.x += deltaMove.x * 0.005;
                    targetRotation.y = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, 
                        targetRotation.y + deltaMove.y * 0.005));
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });
                
                window.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                // Zoom controls
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    targetZoom = Math.max(50, Math.min(400, targetZoom + e.deltaY * 0.1));
                });
                
                // Click for selection
                canvas.addEventListener('click', (e) => {
                    this.checkSelection();
                });
                
                // Smooth camera movement
                this.updateCamera = () => {
                    // Smooth rotation
                    currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
                    currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
                    
                    // Smooth zoom
                    currentZoom += (targetZoom - currentZoom) * 0.05;
                    
                    // Apply camera position
                    const radius = currentZoom;
                    this.camera.position.x = radius * Math.sin(currentRotation.x) * Math.cos(currentRotation.y);
                    this.camera.position.y = radius * Math.sin(currentRotation.y) + 80;
                    this.camera.position.z = radius * Math.cos(currentRotation.x) * Math.cos(currentRotation.y);
                    this.camera.lookAt(0, 20, 0);
                };
            }
            
            buildEnhancedCity() {
                // Create groups for organization
                this.cityGroup = new THREE.Group();
                this.scene.add(this.cityGroup);
                
                // Enhanced platform with details
                this.createEnhancedPlatform();
                
                // Build all 7 districts with proper positioning
                this.createAllDistricts();
                
                // Create connections between districts
                this.createDistrictConnections();
                
                // Add ambient particles
                this.createAmbientParticles();
                
                // Add ground grid
                this.createGroundGrid();
                
                // Update initial stats
                this.updateStats();
            }
            
            createEnhancedPlatform() {
                // Main platform with multiple layers
                const platformGroup = new THREE.Group();
                
                // Base layer
                const baseGeometry = new THREE.CylinderGeometry(120, 125, 4, 64);
                const baseMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0a0a15,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: 0x000510,
                    emissiveIntensity: 0.2
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.receiveShadow = true;
                platformGroup.add(base);
                
                // Ring details
                for (let i = 0; i < 3; i++) {
                    const ringRadius = 130 + i * 10;
                    const ringGeometry = new THREE.TorusGeometry(ringRadius, 1, 8, 64);
                    const ringMaterial = new THREE.MeshStandardMaterial({
                        color: 0x1a1a3e,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: 0x8b5cf6,
                        emissiveIntensity: 0.05
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = 2.5 - i * 0.5;
                    platformGroup.add(ring);
                }
                
                // Tech pattern on platform
                const patternTexture = this.createTechPattern();
                const patternGeometry = new THREE.RingGeometry(10, 115, 64);
                const patternMaterial = new THREE.MeshStandardMaterial({
                    map: patternTexture,
                    transparent: true,
                    opacity: 0.3,
                    emissive: 0x8b5cf6,
                    emissiveIntensity: 0.1
                });
                const pattern = new THREE.Mesh(patternGeometry, patternMaterial);
                pattern.rotation.x = -Math.PI / 2;
                pattern.position.y = 2.1;
                platformGroup.add(pattern);
                
                this.cityGroup.add(platformGroup);
            }
            
            createTechPattern() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Create circuit pattern
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, 512, 512);
                
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.3;
                
                // Draw circuit lines
                for (let i = 0; i < 20; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * 512, Math.random() * 512);
                    for (let j = 0; j < 5; j++) {
                        ctx.lineTo(Math.random() * 512, Math.random() * 512);
                    }
                    ctx.stroke();
                }
                
                // Add nodes
                ctx.fillStyle = '#00ff88';
                for (let i = 0; i < 50; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random() * 512, Math.random() * 512, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                return new THREE.CanvasTexture(canvas);
            }
            
            createGroundGrid() {
                // Custom grid with glow effect
                const gridSize = 300;
                const divisions = 30;
                const gridGeometry = new THREE.BufferGeometry();
                const gridMaterial = new THREE.LineBasicMaterial({
                    color: 0x1a1a3e,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                
                const vertices = [];
                const halfSize = gridSize / 2;
                const step = gridSize / divisions;
                
                for (let i = 0; i <= divisions; i++) {
                    const pos = -halfSize + i * step;
                    vertices.push(-halfSize, 0, pos, halfSize, 0, pos);
                    vertices.push(pos, 0, -halfSize, pos, 0, halfSize);
                }
                
                gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const grid = new THREE.LineSegments(gridGeometry, gridMaterial);
                grid.position.y = 0.1;
                this.scene.add(grid);
            }
            
            createAllDistricts() {
                this.districts = [];
                this.districtMeshes = new Map();
                
                this.state.districts.forEach((districtData, index) => {
                    const district = this.createEnhancedDistrict(districtData, index);
                    this.districts.push(district);
                    this.cityGroup.add(district);
                    
                    // Add point light for district
                    const light = new THREE.PointLight(districtData.color, 0.5, 50);
                    light.position.copy(district.position);
                    light.position.y += 20;
                    this.scene.add(light);
                    this.districtLights.push(light);
                });
            }
            
            createEnhancedDistrict(data, index) {
                const group = new THREE.Group();
                const hexRadius = 35;
                
                // Create hexagonal base with elevation
                const shape = new THREE.Shape();
                const hexVertices = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
                    const x = Math.cos(angle) * hexRadius;
                    const z = Math.sin(angle) * hexRadius;
                    if (i === 0) shape.moveTo(x, z);
                    else shape.lineTo(x, z);
                    hexVertices.push(new THREE.Vector3(x, 0, z));
                }
                shape.closePath();
                
                // Multi-level extrusion
                const extrudeSettings = {
                    depth: 5,
                    bevelEnabled: true,
                    bevelThickness: 2,
                    bevelSize: 2,
                    bevelSegments: 8,
                    steps: 2
                };
                
                const baseGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                baseGeometry.rotateX(-Math.PI / 2);
                
                // Enhanced material with glow
                const baseMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0f0f1a,
                    metalness: 0.7,
                    roughness: 0.3,
                    emissive: data.color,
                    emissiveIntensity: 0.1
                });
                
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 2;
                base.castShadow = true;
                base.receiveShadow = true;
                base.userData = {
                    type: 'district',
                    selectable: true,
                    ...data
                };
                group.add(base);
                this.districtMeshes.set(data.id, base);
                
                // Add glowing edges
                const edgesGeometry = new THREE.EdgesGeometry(baseGeometry);
                const edgesMaterial = new THREE.LineBasicMaterial({
                    color: data.color,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                edges.position.copy(base.position);
                group.add(edges);
                
                // Create buildings with variety
                const buildings = this.createDistrictBuildings(data, hexRadius);
                buildings.forEach(building => group.add(building));
                
                // Add holographic label
                const label = this.createDistrictLabel(data.name, data.color);
                label.position.y = 40;
                group.add(label);
                
                // Position district
                group.position.x = data.position.x;
                group.position.z = data.position.z;
                
                // Add floating particles around district
                const particles = this.createDistrictParticles(data.color, hexRadius);
                group.add(particles);
                
                return group;
            }
            
            createDistrictBuildings(districtData, hexRadius) {
                const buildings = [];
                const buildingCount = districtData.nodes.length;
                
                districtData.nodes.forEach((node, i) => {
                    // Vary building positions
                    const angle = (i / buildingCount) * Math.PI * 2 + Math.random() * 0.2;
                    const radius = hexRadius * (0.3 + Math.random() * 0.4);
                    
                    // Create building group
                    const buildingGroup = new THREE.Group();
                    
                    // Base building
                    const width = 6 + Math.random() * 4;
                    const depth = 6 + Math.random() * 4;
                    const height = 15 + node.importance * 10 + Math.random() * 10;
                    
                    const geometry = new THREE.BoxGeometry(width, height, depth);
                    
                    // Procedural building texture
                    const material = new THREE.MeshStandardMaterial({
                        color: 0x1a1a2e,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: districtData.color,
                        emissiveIntensity: 0.02
                    });
                    
                    const building = new THREE.Mesh(geometry, material);
                    building.position.y = height / 2;
                    building.castShadow = true;
                    building.receiveShadow = true;
                    building.userData = {
                        type: 'building',
                        selectable: true,
                        district: districtData.id,
                        ...node
                    };
                    buildingGroup.add(building);
                    
                    // Add windows with glow
                    const windowRows = Math.floor(height / 3);
                    const windowsPerRow = 4;
                    
                    for (let row = 0; row < windowRows; row++) {
                        for (let col = 0; col < windowsPerRow; col++) {
                            if (Math.random() > 0.3) { // Some windows are off
                                const windowGeometry = new THREE.PlaneGeometry(1, 1.5);
                                const windowMaterial = new THREE.MeshBasicMaterial({
                                    color: districtData.color,
                                    emissive: districtData.color,
                                    emissiveIntensity: 1,
                                    blending: THREE.AdditiveBlending
                                });
                                
                                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                                const side = Math.floor(col / 2);
                                const xOffset = (col % 2) * 2 - 1;
                                
                                if (side === 0) {
                                    window.position.x = (width / 2 + 0.1) * xOffset;
                                    window.position.z = 0;
                                    window.rotation.y = Math.PI / 2 * xOffset;
                                } else {
                                    window.position.z = (depth / 2 + 0.1) * xOffset;
                                    window.position.x = 0;
                                    window.rotation.y = side === 1 ? 0 : Math.PI;
                                }
                                
                                window.position.y = 3 + row * 3;
                                buildingGroup.add(window);
                            }
                        }
                    }
                    
                    // Add top beacon for important buildings
                    if (node.importance >= 2) {
                        const beaconGeometry = new THREE.CylinderGeometry(0.5, 1, 3, 8);
                        const beaconMaterial = new THREE.MeshBasicMaterial({
                            color: districtData.color,
                            transparent: true,
                            opacity: 0.8,
                            blending: THREE.AdditiveBlending
                        });
                        const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
                        beacon.position.y = height + 2;
                        buildingGroup.add(beacon);
                        
                        // Add point light at top
                        const beaconLight = new THREE.PointLight(districtData.color, 0.3, 20);
                        beaconLight.position.y = height + 2;
                        buildingGroup.add(beaconLight);
                    }
                    
                    // Position building
                    buildingGroup.position.x = Math.cos(angle) * radius;
                    buildingGroup.position.z = Math.sin(angle) * radius;
                    buildingGroup.position.y = 7;
                    
                    // Random rotation for variety
                    buildingGroup.rotation.y = Math.random() * Math.PI * 2;
                    
                    buildings.push(buildingGroup);
                });
                
                return buildings;
            }
            
            createDistrictLabel(text, color) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                
                // Create gradient background
                const gradient = ctx.createLinearGradient(0, 0, 256, 0);
                gradient.addColorStop(0, 'transparent');
                gradient.addColorStop(0.5, `rgba(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255}, 0.1)`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 256, 64);
                
                // Draw text
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text.toUpperCase(), 128, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                
                const geometry = new THREE.PlaneGeometry(30, 7.5);
                const label = new THREE.Mesh(geometry, material);
                
                return label;
            }
            
            createDistrictParticles(color, radius) {
                const particleCount = 50;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                const colorObj = new THREE.Color(color);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = radius + Math.random() * 20;
                    const y = Math.random() * 40;
                    
                    positions[i * 3] = Math.cos(angle) * r;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = Math.sin(angle) * r;
                    
                    colors[i * 3] = colorObj.r;
                    colors[i * 3 + 1] = colorObj.g;
                    colors[i * 3 + 2] = colorObj.b;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                const particles = new THREE.Points(geometry, material);
                particles.userData.basePositions = positions.slice();
                
                return particles;
            }
            
            createDistrictConnections() {
                this.connections = [];
                
                // Create connections between adjacent districts
                const connectionPairs = [
                    ['central-core', 'data-processing'],
                    ['central-core', 'ai-intelligence'],
                    ['central-core', 'security-fortress'],
                    ['data-processing', 'analytics-engine'],
                    ['ai-intelligence', 'neural-network'],
                    ['security-fortress', 'monitoring-hub'],
                    ['analytics-engine', 'neural-network']
                ];
                
                connectionPairs.forEach(([fromId, toId]) => {
                    const fromDistrict = this.districts.find(d => d.children[0]?.userData?.id === fromId);
                    const toDistrict = this.districts.find(d => d.children[0]?.userData?.id === toId);
                    
                    if (fromDistrict && toDistrict) {
                        const connection = this.createConnection(
                            fromDistrict.position,
                            toDistrict.position,
                            fromDistrict.children[0].userData.color
                        );
                        this.connections.push(connection);
                        this.cityGroup.add(connection);
                    }
                });
            }
            
            createConnection(start, end, color) {
                const connectionGroup = new THREE.Group();
                
                // Main connection line
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(start.x, 10, start.z),
                    new THREE.Vector3((start.x + end.x) / 2, 20, (start.z + end.z) / 2),
                    new THREE.Vector3(end.x, 10, end.z)
                ]);
                
                const tubeGeometry = new THREE.TubeGeometry(curve, 32, 0.5, 8, false);
                const tubeMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a1a3e,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: color,
                    emissiveIntensity: 0.1
                });
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                connectionGroup.add(tube);
                
                // Flow particles
                const flowParticles = this.createFlowParticles(curve, color);
                connectionGroup.add(flowParticles);
                
                return connectionGroup;
            }
            
            createFlowParticles(curve, color) {
                const particleCount = 20;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const offsets = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    const t = i / particleCount;
                    const point = curve.getPoint(t);
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                    offsets[i] = t;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 1));
                
                const material = createShaderMaterial(
                    {
                        time: { value: 0 },
                        color: { value: new THREE.Color(color) }
                    },
                    flowVertexShader,
                    flowFragmentShader
                );
                
                const particles = new THREE.Points(geometry, material);
                particles.userData.curve = curve;
                
                return particles;
            }
            
            createAmbientParticles() {
                const particleCount = this.state.particles.ambient;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 400;
                    positions[i * 3 + 1] = Math.random() * 200;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
                    
                    const color = new THREE.Color();
                    color.setHSL(Math.random() * 0.1 + 0.7, 0.8, 0.5);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = Math.random() * 2 + 1;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                this.ambientParticles = new THREE.Points(geometry, material);
                this.scene.add(this.ambientParticles);
            }
            
            setupPostProcessing() {
                // Create composer
                this.composer = new EffectComposer(this.renderer);
                
                // Add render pass
                const renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);
                
                // Add bloom pass
                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    1.5,  // strength
                    0.4,  // radius
                    0.85  // threshold
                );
                this.composer.addPass(bloomPass);
                
                // Custom shader pass for final touches
                const finalShader = {
                    uniforms: {
                        tDiffuse: { value: null },
                        time: { value: 0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tDiffuse;
                        uniform float time;
                        varying vec2 vUv;
                        
                        void main() {
                            vec4 color = texture2D(tDiffuse, vUv);
                            
                            // Add subtle vignette
                            float vignette = smoothstep(0.8, 0.2, length(vUv - 0.5));
                            color.rgb *= vignette * 0.8 + 0.2;
                            
                            // Add slight chromatic aberration
                            vec2 offset = (vUv - 0.5) * 0.001;
                            color.r = texture2D(tDiffuse, vUv + offset).r;
                            color.b = texture2D(tDiffuse, vUv - offset).b;
                            
                            gl_FragColor = color;
                        }
                    `
                };
                
                const finalPass = new ShaderPass(finalShader);
                this.composer.addPass(finalPass);
            }
            
            checkHover() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.cityGroup.children, true);
                
                const tooltip = document.getElementById('tooltip');
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.selectable) {
                        document.body.style.cursor = 'pointer';
                        
                        // Show tooltip
                        tooltip.textContent = object.userData.name || object.userData.type;
                        tooltip.style.left = (this.mouse.x + 1) * window.innerWidth / 2 + 'px';
                        tooltip.style.top = (1 - this.mouse.y) * window.innerHeight / 2 + 'px';
                        tooltip.classList.add('visible');
                        
                        // Emit hover event
                        this.emit('object-hover', object.userData);
                    } else {
                        document.body.style.cursor = 'default';
                        tooltip.classList.remove('visible');
                    }
                } else {
                    document.body.style.cursor = 'default';
                    tooltip.classList.remove('visible');
                }
            }
            
            checkSelection() {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.cityGroup.children, true);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.selectable) {
                        this.emit('object-select', object.userData);
                    }
                }
            }
            
            applyMode() {
                const modes = {
                    explorer: {
                        fogDensity: 0.0008,
                        fogColor: 0x000510,
                        particleColor: 0x8b5cf6,
                        lightIntensity: 0.6
                    },
                    architect: {
                        fogDensity: 0.0002,
                        fogColor: 0x0a0a15,
                        particleColor: 0x00ff88,
                        lightIntensity: 0.8
                    },
                    matrix: {
                        fogDensity: 0.002,
                        fogColor: 0x001100,
                        particleColor: 0x00ff00,
                        lightIntensity: 0.4
                    },
                    neural: {
                        fogDensity: 0.001,
                        fogColor: 0x1a0033,
                        particleColor: 0xff00ff,
                        lightIntensity: 0.5
                    }
                };
                
                const config = modes[this.state.mode];
                
                // Animate fog transition
                this.scene.fog.density = config.fogDensity;
                this.scene.fog.color.setHex(config.fogColor);
                
                // Update particle colors
                if (this.ambientParticles) {
                    this.ambientParticles.material.color.setHex(config.particleColor);
                }
                
                // Adjust lighting
                this.scene.children.forEach(child => {
                    if (child instanceof THREE.DirectionalLight) {
                        child.intensity = config.lightIntensity;
                    }
                });
                
                // Mode-specific effects
                if (this.state.mode === 'neural') {
                    this.addNeuralConnections();
                } else {
                    this.removeNeuralConnections();
                }
            }
            
            addNeuralConnections() {
                // Create neural network visualization between all districts
                this.neuralConnections = new THREE.Group();
                
                for (let i = 0; i < this.districts.length; i++) {
                    for (let j = i + 1; j < this.districts.length; j++) {
                        const start = this.districts[i].position;
                        const end = this.districts[j].position;
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(start.x, 20, start.z),
                            new THREE.Vector3(end.x, 20, end.z)
                        ]);
                        
                        const material = new THREE.LineBasicMaterial({
                            color: 0xff00ff,
                            transparent: true,
                            opacity: 0.2,
                            blending: THREE.AdditiveBlending
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        this.neuralConnections.add(line);
                    }
                }
                
                this.scene.add(this.neuralConnections);
            }
            
            removeNeuralConnections() {
                if (this.neuralConnections) {
                    this.scene.remove(this.neuralConnections);
                    this.neuralConnections = null;
                }
            }
            
            showInspector() {
                const inspector = document.getElementById('inspector');
                const title = document.getElementById('inspector-title');
                const type = document.getElementById('inspector-type');
                const status = document.getElementById('inspector-status');
                const connections = document.getElementById('inspector-connections');
                
                if (this.state.selected) {
                    title.textContent = this.state.selected.name || 'Unknown System';
                    type.textContent = this.state.selected.type || 'Unknown';
                    status.textContent = 'Active';
                    connections.textContent = Math.floor(Math.random() * 100) + ' active';
                    
                    inspector.classList.add('visible');
                    
                    // Highlight selected object
                    this.highlightObject(this.state.selected);
                }
            }
            
            highlightObject(data) {
                // Remove previous highlight
                if (this.highlight) {
                    this.scene.remove(this.highlight);
                }
                
                // Find object to highlight
                let target = null;
                if (data.type === 'district') {
                    target = this.districtMeshes.get(data.id);
                }
                
                if (target) {
                    // Create glow effect around selected object
                    const glowGeometry = target.geometry.clone();
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: data.color || 0x8b5cf6,
                        transparent: true,
                        opacity: 0.5,
                        side: THREE.BackSide
                    });
                    
                    this.highlight = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.highlight.position.copy(target.position);
                    this.highlight.scale.multiplyScalar(1.1);
                    target.parent.add(this.highlight);
                }
            }
            
            updateStats() {
                let objectCount = 0;
                let particleCount = 0;
                
                this.scene.traverse((object) => {
                    if (object instanceof THREE.Mesh) objectCount++;
                    if (object instanceof THREE.Points) {
                        particleCount += object.geometry.attributes.position.count;
                    }
                });
                
                this.state.stats = {
                    fps: this.getFPS ? this.getFPS() : 60,
                    objects: objectCount,
                    particles: particleCount,
                    drawCalls: this.renderer.info.render.calls
                };
                
                // Update UI
                document.getElementById('objects').textContent = this.state.stats.objects;
                document.getElementById('particles').textContent = this.state.stats.particles;
                document.getElementById('drawCalls').textContent = this.state.stats.drawCalls;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const time = performance.now() * 0.001;
                
                // Update camera
                if (this.updateCamera) {
                    this.updateCamera();
                }
                
                // Animate particles
                if (this.ambientParticles) {
                    this.ambientParticles.rotation.y += 0.0001;
                    
                    // Float effect
                    const positions = this.ambientParticles.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] += Math.sin(time + i) * 0.02;
                        if (positions[i] > 200) positions[i] = 0;
                    }
                    this.ambientParticles.geometry.attributes.position.needsUpdate = true;
                }
                
                // Animate district particles
                this.districts?.forEach((district, i) => {
                    district.children.forEach(child => {
                        if (child instanceof THREE.Points && child.userData.basePositions) {
                            const positions = child.geometry.attributes.position.array;
                            const basePositions = child.userData.basePositions;
                            
                            for (let j = 0; j < positions.length; j += 3) {
                                positions[j] = basePositions[j] + Math.sin(time * 2 + j) * 0.5;
                                positions[j + 1] = basePositions[j + 1] + Math.sin(time + j) * 2;
                                positions[j + 2] = basePositions[j + 2] + Math.cos(time * 2 + j) * 0.5;
                            }
                            child.geometry.attributes.position.needsUpdate = true;
                        }
                    });
                    
                    // Pulse effect
                    const scale = 1 + Math.sin(time * 2 + i) * 0.01;
                    district.scale.set(scale, 1, scale);
                });
                
                // Animate connections
                this.connections?.forEach(connection => {
                    connection.children.forEach(child => {
                        if (child instanceof THREE.Points && child.material.uniforms) {
                            child.material.uniforms.time.value = time;
                        }
                    });
                });
                
                // Update district lights
                this.districtLights?.forEach((light, i) => {
                    light.intensity = 0.5 + Math.sin(time * 3 + i * 0.5) * 0.1;
                });
                
                // Update stats periodically
                if (Math.floor(time) % 2 === 0) {
                    this.updateStats();
                }
                
                // Render with post-processing
                if (this.composer) {
                    this.composer.render();
                } else {
                    this.renderer.render(this.scene, this.camera);
                }
            }
            
            getFullDistrictsData() {
                return [
                    {
                        id: 'central-core',
                        name: 'Central Core',
                        color: 0x8b5cf6,
                        position: { x: 0, z: 0 },
                        importance: 3,
                        nodes: [
                            { name: 'Master Controller', type: 'core', importance: 3 },
                            { name: 'Event Bus', type: 'infrastructure', importance: 3 },
                            { name: 'State Manager', type: 'storage', importance: 2 },
                            { name: 'Task Scheduler', type: 'processor', importance: 2 },
                            { name: 'Cache Layer', type: 'storage', importance: 2 }
                        ]
                    },
                    {
                        id: 'data-processing',
                        name: 'Data Processing',
                        color: 0x00ff88,
                        position: { x: 80, z: 0 },
                        importance: 2,
                        nodes: [
                            { name: 'Stream Processor', type: 'processor', importance: 3 },
                            { name: 'ETL Pipeline', type: 'infrastructure', importance: 2 },
                            { name: 'Data Lake', type: 'storage', importance: 2 },
                            { name: 'Transform Engine', type: 'processor', importance: 2 }
                        ]
                    },
                    {
                        id: 'ai-intelligence',
                        name: 'AI Intelligence',
                        color: 0xff00aa,
                        position: { x: -80, z: 0 },
                        importance: 3,
                        nodes: [
                            { name: 'Neural Engine', type: 'ai', importance: 3 },
                            { name: 'ML Models', type: 'ai', importance: 3 },
                            { name: 'Decision Matrix', type: 'processor', importance: 2 },
                            { name: 'Training Pipeline', type: 'infrastructure', importance: 2 }
                        ]
                    },
                    {
                        id: 'security-fortress',
                        name: 'Security Fortress',
                        color: 0xff4444,
                        position: { x: 40, z: -70 },
                        importance: 3,
                        nodes: [
                            { name: 'Firewall Core', type: 'security', importance: 3 },
                            { name: 'Threat Detector', type: 'security', importance: 3 },
                            { name: 'Encryption Engine', type: 'processor', importance: 2 },
                            { name: 'Access Control', type: 'security', importance: 2 }
                        ]
                    },
                    {
                        id: 'analytics-engine',
                        name: 'Analytics Engine',
                        color: 0x44aaff,
                        position: { x: -40, z: -70 },
                        importance: 2,
                        nodes: [
                            { name: 'Metrics Collector', type: 'monitoring', importance: 2 },
                            { name: 'Dashboard Core', type: 'visualization', importance: 2 },
                            { name: 'Report Generator', type: 'processor', importance: 2 }
                        ]
                    },
                    {
                        id: 'neural-network',
                        name: 'Neural Network',
                        color: 0xffaa00,
                        position: { x: 40, z: 70 },
                        importance: 2,
                        nodes: [
                            { name: 'Synapse Grid', type: 'network', importance: 2 },
                            { name: 'Node Cluster', type: 'infrastructure', importance: 2 },
                            { name: 'Signal Router', type: 'network', importance: 2 }
                        ]
                    },
                    {
                        id: 'monitoring-hub',
                        name: 'Monitoring Hub',
                        color: 0x00ffff,
                        position: { x: -40, z: 70 },
                        importance: 2,
                        nodes: [
                            { name: 'Health Monitor', type: 'monitoring', importance: 2 },
                            { name: 'Alert System', type: 'monitoring', importance: 2 },
                            { name: 'Log Aggregator', type: 'storage', importance: 1 }
                        ]
                    }
                ];
            }
        }
        
        // Register enhanced component
        customElements.define('enhanced-scene-component', EnhancedSceneComponent);
        
        // Enhanced UI Controller using BRUTAL
        const UIController = compose(
            withState({ currentMode: 'explorer' }),
            withEvents({
                click(e) {
                    const modeBtn = e.target.closest('.mode-btn');
                    if (modeBtn) {
                        const mode = modeBtn.dataset.mode;
                        
                        // Update active state with smooth transition
                        document.querySelectorAll('.mode-btn').forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.mode === mode);
                        });
                        
                        // Dispatch mode change
                        const scene = document.querySelector('enhanced-scene-component');
                        scene.dispatchEvent(new CustomEvent('mode-change', { detail: mode }));
                    }
                }
            })
        )(document.getElementById('ui'));
        
        // Initialize enhanced scene
        const scene = document.createElement('enhanced-scene-component');
        document.body.appendChild(scene);
        
        // Window resize handler with debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const sceneComponent = document.querySelector('enhanced-scene-component');
                if (sceneComponent.camera && sceneComponent.renderer) {
                    sceneComponent.camera.aspect = window.innerWidth / window.innerHeight;
                    sceneComponent.camera.updateProjectionMatrix();
                    sceneComponent.renderer.setSize(window.innerWidth, window.innerHeight);
                    sceneComponent.composer?.setSize(window.innerWidth, window.innerHeight);
                }
            }, 100);
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            const scene = document.querySelector('enhanced-scene-component');
            if (!scene) return;
            
            switch(e.key) {
                case '1':
                    scene.dispatchEvent(new CustomEvent('mode-change', { detail: 'explorer' }));
                    break;
                case '2':
                    scene.dispatchEvent(new CustomEvent('mode-change', { detail: 'architect' }));
                    break;
                case '3':
                    scene.dispatchEvent(new CustomEvent('mode-change', { detail: 'matrix' }));
                    break;
                case '4':
                    scene.dispatchEvent(new CustomEvent('mode-change', { detail: 'neural' }));
                    break;
                case 'Escape':
                    document.getElementById('inspector').classList.remove('visible');
                    break;
            }
        });
    </script>
</body>
</html>