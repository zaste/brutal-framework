<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CompanyCity - BRUTAL V6 Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, 'SF Pro Display', 'Inter', sans-serif;
            overflow: hidden;
            position: relative;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Glass Panel Base */
        .panel {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 16px;
            pointer-events: auto;
        }
        
        /* Mode Display */
        #mode-display {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            font-size: 13px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #8b5cf6;
        }
        
        /* Navigation Breadcrumb */
        #navigation {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 24px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .nav-separator {
            color: rgba(139, 92, 246, 0.5);
        }
        
        .nav-item.active {
            color: #8b5cf6;
            font-weight: 500;
        }
        
        /* Stats Panel */
        #stats-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            padding: 24px;
            width: 280px;
        }
        
        .panel-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #8b5cf6;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.1);
        }
        
        .stat-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .stat-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 600;
            color: #00ff88;
        }
        
        /* FPS Monitor */
        #fps-monitor {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 16px 24px;
            min-width: 120px;
            text-align: center;
        }
        
        #fps-value {
            font-size: 32px;
            font-weight: 700;
            color: #00ff88;
            margin-bottom: 4px;
        }
        
        #fps-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* District Labels */
        .district-label {
            position: absolute;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        
        .district-label.visible {
            opacity: 0.9;
        }
        
        /* Node Info Tooltip */
        #node-tooltip {
            position: absolute;
            padding: 16px;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 92, 246, 0.5);
            border-radius: 12px;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s;
            transform: translate(-50%, -120%);
        }
        
        #node-tooltip.visible {
            opacity: 1;
        }
        
        .tooltip-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .tooltip-info {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
        }
        
        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a0033, #000);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 1s;
        }
        
        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-content {
            text-align: center;
        }
        
        .loading-title {
            font-size: 48px;
            font-weight: 700;
            background: linear-gradient(135deg, #8b5cf6, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
            letter-spacing: -1px;
        }
        
        .loading-bar {
            width: 300px;
            height: 3px;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin: 0 auto;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #8b5cf6, #00ff88);
            width: 0%;
            transition: width 0.3s;
        }
        
        .loading-status {
            margin-top: 20px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-content">
            <h1 class="loading-title">CompanyCity</h1>
            <div class="loading-bar">
                <div class="loading-progress" id="loading-progress"></div>
            </div>
            <div class="loading-status" id="loading-status">Initializing BRUTAL V6...</div>
        </div>
    </div>
    
    <!-- Canvas -->
    <div id="canvas-container"></div>
    
    <!-- UI Layer -->
    <div id="ui-layer">
        <!-- Mode Display -->
        <div id="mode-display" class="panel">
            Explorer Mode
        </div>
        
        <!-- Navigation -->
        <div id="navigation" class="panel">
            <span class="nav-item active">CompanyCity</span>
            <span class="nav-separator">›</span>
            <span class="nav-item" id="nav-district">Overview</span>
            <span class="nav-separator">›</span>
            <span class="nav-item" id="nav-node">All Nodes</span>
        </div>
        
        <!-- Stats Panel -->
        <div id="stats-panel" class="panel">
            <h3 class="panel-title">System Status</h3>
            <div class="stat-item">
                <span class="stat-label">Active Districts</span>
                <span class="stat-value" id="stat-districts">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Total Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Connections</span>
                <span class="stat-value" id="stat-connections">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Data Flow</span>
                <span class="stat-value" id="stat-flow">0</span>
            </div>
        </div>
        
        <!-- FPS Monitor -->
        <div id="fps-monitor" class="panel">
            <div id="fps-value">60</div>
            <div id="fps-label">FPS</div>
        </div>
        
        <!-- Node Tooltip -->
        <div id="node-tooltip">
            <div class="tooltip-title" id="tooltip-title"></div>
            <div class="tooltip-info" id="tooltip-info"></div>
        </div>
    </div>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    
    <script type="module">
        // BRUTAL V6 Composition System
        const compose = (...behaviors) => (Base = HTMLElement) => {
            return behaviors.reduce((Acc, behavior) => behavior(Acc), Base);
        };
        
        const withState = (initialState) => (Base) => {
            return class extends Base {
                constructor() {
                    super();
                    this.state = new Proxy({ ...initialState }, {
                        set: (target, prop, value) => {
                            const oldValue = target[prop];
                            target[prop] = value;
                            if (oldValue !== value && this.stateChanged) {
                                this.stateChanged(prop, value, oldValue);
                            }
                            return true;
                        }
                    });
                }
            };
        };
        
        const withEvents = (handlers) => (Base) => {
            return class extends Base {
                constructor() {
                    super();
                    this.eventHandlers = handlers;
                }
                
                connectedCallback() {
                    super.connectedCallback?.();
                    Object.entries(this.eventHandlers).forEach(([event, handler]) => {
                        this.addEventListener(event, handler.bind(this));
                    });
                }
            };
        };
        
        const withThree = () => (Base) => {
            return class extends Base {
                constructor() {
                    super();
                    this.setupThree();
                }
                
                setupThree() {
                    // Scene
                    this.scene = new THREE.Scene();
                    this.scene.fog = new THREE.FogExp2(0x000000, 0.0015);
                    
                    // Camera
                    this.camera = new THREE.PerspectiveCamera(
                        45, window.innerWidth / window.innerHeight, 0.1, 2000
                    );
                    this.camera.position.set(200, 150, 200);
                    this.camera.lookAt(0, 0, 0);
                    
                    // Renderer
                    this.renderer = new THREE.WebGLRenderer({ 
                        antialias: true,
                        powerPreference: "high-performance"
                    });
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    this.renderer.shadowMap.enabled = true;
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    this.renderer.toneMappingExposure = 1.2;
                    
                    // Controls
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                    this.controls.maxDistance = 800;
                    this.controls.minDistance = 50;
                    this.controls.maxPolarAngle = Math.PI / 2;
                    
                    // Post-processing
                    this.composer = new THREE.EffectComposer(this.renderer);
                    const renderPass = new THREE.RenderPass(this.scene, this.camera);
                    this.composer.addPass(renderPass);
                    
                    const bloomPass = new THREE.UnrealBloomPass(
                        new THREE.Vector2(window.innerWidth, window.innerHeight),
                        1.5, 0.4, 0.85
                    );
                    this.composer.addPass(bloomPass);
                    
                    // Resize handler
                    window.addEventListener('resize', () => {
                        this.camera.aspect = window.innerWidth / window.innerHeight;
                        this.camera.updateProjectionMatrix();
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                        this.composer.setSize(window.innerWidth, window.innerHeight);
                    });
                    
                    // Mouse tracking
                    this.mouse = new THREE.Vector2();
                    this.raycaster = new THREE.Raycaster();
                    
                    window.addEventListener('mousemove', (e) => {
                        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                        this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    });
                }
            };
        };
        
        // Global Configuration
        const SCALE_CONFIG = {
            platformRadius: 100,
            districtScale: 0.18,
            buildingScale: 0.06,
            heightScale: 0.15,
            spacing: 1.2
        };
        
        // District Configuration
        const DISTRICTS = [
            {
                id: 'central-core',
                name: 'Central Core',
                color: 0x9C27B0,
                position: { q: 0, r: 0 },
                scale: 1.5,
                importance: 3,
                nodes: [
                    { id: 'event-bus', name: 'Event Bus', type: 'core', importance: 3 },
                    { id: 'message-queue', name: 'Message Queue', type: 'storage', importance: 2 },
                    { id: 'api-router', name: 'API Router', type: 'processor', importance: 2 },
                    { id: 'service-mesh', name: 'Service Mesh', type: 'network', importance: 2 }
                ]
            },
            {
                id: 'processing',
                name: 'Processing Hub',
                color: 0x8B5CF6,
                position: { q: 1, r: 0 },
                scale: 1.2,
                importance: 2,
                nodes: [
                    { id: 'lead-capture', name: 'Lead Capture', type: 'processor', importance: 2 },
                    { id: 'validation', name: 'Validation Engine', type: 'processor', importance: 2 },
                    { id: 'scoring', name: 'Scoring System', type: 'ai', importance: 3 },
                    { id: 'routing', name: 'Smart Router', type: 'network', importance: 1 }
                ]
            },
            {
                id: 'data-pipeline',
                name: 'Data Pipeline',
                color: 0x00BCD4,
                position: { q: 0, r: 1 },
                scale: 1.1,
                importance: 2,
                nodes: [
                    { id: 'etl-pipeline', name: 'ETL Pipeline', type: 'processor', importance: 2 },
                    { id: 'transform-alpha', name: 'Transform α', type: 'transformer', importance: 1 },
                    { id: 'transform-beta', name: 'Transform β', type: 'transformer', importance: 1 },
                    { id: 'data-lake', name: 'Data Lake', type: 'storage', importance: 3 }
                ]
            },
            {
                id: 'ai-services',
                name: 'AI Services',
                color: 0x4CAF50,
                position: { q: -1, r: 1 },
                scale: 1.0,
                importance: 3,
                nodes: [
                    { id: 'orchestrator', name: 'AI Orchestrator', type: 'core', importance: 3 },
                    { id: 'ml-model-1', name: 'ML Model Alpha', type: 'ai', importance: 2 },
                    { id: 'ml-model-2', name: 'ML Model Beta', type: 'ai', importance: 2 },
                    { id: 'decision-engine', name: 'Decision Engine', type: 'processor', importance: 2 }
                ]
            },
            {
                id: 'integration',
                name: 'Integration Layer',
                color: 0xFF9800,
                position: { q: -1, r: 0 },
                scale: 1.0,
                importance: 1,
                nodes: [
                    { id: 'api-gateway', name: 'API Gateway', type: 'network', importance: 2 },
                    { id: 'webhook-handler', name: 'Webhook Handler', type: 'processor', importance: 1 },
                    { id: 'event-publisher', name: 'Event Publisher', type: 'network', importance: 1 },
                    { id: 'adapter-bank', name: 'Adapter Bank', type: 'storage', importance: 1 }
                ]
            },
            {
                id: 'monitoring',
                name: 'Monitoring & Analytics',
                color: 0x03A9F4,
                position: { q: 0, r: -1 },
                scale: 1.0,
                importance: 2,
                nodes: [
                    { id: 'metrics-collector', name: 'Metrics Collector', type: 'monitor', importance: 2 },
                    { id: 'aggregator', name: 'Data Aggregator', type: 'processor', importance: 1 },
                    { id: 'visualizer', name: 'Visualizer', type: 'output', importance: 1 },
                    { id: 'alerting', name: 'Alert Engine', type: 'monitor', importance: 2 }
                ]
            },
            {
                id: 'security',
                name: 'Security & Compliance',
                color: 0xff0066,
                position: { q: 1, r: -1 },
                scale: 1.0,
                importance: 3,
                nodes: [
                    { id: 'auth-service', name: 'Auth Service', type: 'security', importance: 3 },
                    { id: 'encryption', name: 'Encryption Layer', type: 'security', importance: 2 },
                    { id: 'audit-log', name: 'Audit Logger', type: 'monitor', importance: 1 },
                    { id: 'threat-detect', name: 'Threat Detection', type: 'security', importance: 2 }
                ]
            }
        ];
        
        // Connection Map
        const CONNECTIONS = [
            ['event-bus', 'lead-capture'],
            ['event-bus', 'etl-pipeline'],
            ['event-bus', 'orchestrator'],
            ['event-bus', 'api-gateway'],
            ['event-bus', 'metrics-collector'],
            ['event-bus', 'auth-service'],
            ['lead-capture', 'validation'],
            ['validation', 'scoring'],
            ['scoring', 'routing'],
            ['routing', 'orchestrator'],
            ['etl-pipeline', 'transform-alpha'],
            ['etl-pipeline', 'transform-beta'],
            ['transform-alpha', 'data-lake'],
            ['transform-beta', 'data-lake'],
            ['data-lake', 'orchestrator'],
            ['orchestrator', 'ml-model-1'],
            ['orchestrator', 'ml-model-2'],
            ['ml-model-1', 'decision-engine'],
            ['ml-model-2', 'decision-engine'],
            ['api-gateway', 'webhook-handler'],
            ['api-gateway', 'event-publisher']
        ];
        
        // City Component
        const CityComponent = compose(
            withState({
                districts: [],
                nodes: new Map(),
                buildings: [],
                connections: [],
                particles: [],
                hoveredNode: null,
                selectedNode: null,
                fps: 60,
                frameCount: 0,
                lastTime: 0
            }),
            withEvents({
                'click': function(e) {
                    this.handleClick(e);
                },
                'node-hover': function(e) {
                    this.handleNodeHover(e.detail);
                },
                'node-select': function(e) {
                    this.handleNodeSelect(e.detail);
                }
            }),
            withThree()
        )(HTMLElement);
        
        // Define custom element
        customElements.define('city-component', CityComponent);
        
        // Create instance
        const city = document.createElement('city-component');
        
        // Add methods
        Object.assign(city, {
            async init() {
                // Loading sequence
                const steps = [
                    { progress: 10, status: 'Building hexagonal grid...' },
                    { progress: 30, status: 'Constructing districts...' },
                    { progress: 50, status: 'Creating neural connections...' },
                    { progress: 70, status: 'Initializing particle systems...' },
                    { progress: 90, status: 'Applying shaders...' },
                    { progress: 100, status: 'Welcome to CompanyCity' }
                ];
                
                for (const step of steps) {
                    document.getElementById('loading-progress').style.width = step.progress + '%';
                    document.getElementById('loading-status').textContent = step.status;
                    await this.delay(200);
                }
                
                // Setup scene
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                this.createEnvironment();
                this.createDistricts();
                this.createConnections();
                this.createParticles();
                this.setupLighting();
                
                // Start animation
                this.animate();
                
                // Hide loading
                await this.delay(500);
                document.getElementById('loading-screen').classList.add('hidden');
            },
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },
            
            createEnvironment() {
                // Platform
                const platformGeometry = new THREE.CylinderGeometry(
                    SCALE_CONFIG.platformRadius, 
                    SCALE_CONFIG.platformRadius, 
                    1, 
                    64
                );
                const platformMaterial = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                platform.position.y = -0.5;
                platform.receiveShadow = true;
                this.scene.add(platform);
                
                // Grid overlay
                const gridHelper = new THREE.GridHelper(200, 40, 0x2a2a3e, 0x1a1a2e);
                gridHelper.position.y = 0.1;
                this.scene.add(gridHelper);
                
                // Add glow ring
                const ringGeometry = new THREE.RingGeometry(
                    SCALE_CONFIG.platformRadius - 2,
                    SCALE_CONFIG.platformRadius,
                    64
                );
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x8b5cf6,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.1;
                this.scene.add(ring);
            },
            
            createDistricts() {
                let totalNodes = 0;
                
                DISTRICTS.forEach(districtData => {
                    const district = new THREE.Group();
                    district.userData = districtData;
                    
                    // Calculate position from axial coordinates
                    const spacing = SCALE_CONFIG.platformRadius * 0.5 * SCALE_CONFIG.spacing;
                    const x = spacing * Math.sqrt(3) * (districtData.position.q + districtData.position.r/2);
                    const z = spacing * 3/2 * districtData.position.r;
                    district.position.set(x, 0, z);
                    
                    // Create hexagonal platform
                    const shape = new THREE.Shape();
                    const hexRadius = SCALE_CONFIG.platformRadius * SCALE_CONFIG.districtScale * districtData.scale;
                    
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 + Math.PI / 6;
                        const px = Math.cos(angle) * hexRadius;
                        const py = Math.sin(angle) * hexRadius;
                        if (i === 0) shape.moveTo(px, py);
                        else shape.lineTo(px, py);
                    }
                    shape.closePath();
                    
                    const platformDepth = hexRadius * 0.15;
                    const extrudeSettings = {
                        depth: platformDepth,
                        bevelEnabled: true,
                        bevelThickness: platformDepth * 0.1,
                        bevelSize: platformDepth * 0.1,
                        bevelSegments: 3
                    };
                    
                    const platformGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                    platformGeometry.rotateX(-Math.PI / 2);
                    
                    const platformMaterial = new THREE.MeshStandardMaterial({
                        color: 0x1a1a1a,
                        metalness: 0.7,
                        roughness: 0.3,
                        emissive: districtData.color,
                        emissiveIntensity: districtData.id === 'central-core' ? 0.15 : 0.08
                    });
                    
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    platform.position.y = platformDepth / 2;
                    platform.castShadow = true;
                    platform.receiveShadow = true;
                    district.add(platform);
                    
                    // Edge glow
                    const edgeGeometry = new THREE.EdgesGeometry(platformGeometry);
                    const edgeMaterial = new THREE.LineBasicMaterial({
                        color: districtData.color,
                        linewidth: 2,
                        transparent: true,
                        opacity: 0.6
                    });
                    const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                    platform.add(edges);
                    
                    // Create buildings
                    const positions = this.calculateBuildingPositions(districtData.nodes.length, hexRadius);
                    
                    districtData.nodes.forEach((nodeData, index) => {
                        const building = this.createBuilding(nodeData, districtData, positions[index]);
                        building.position.y = building.userData.height / 2 + platformDepth;
                        district.add(building);
                        this.state.buildings.push(building);
                        
                        // Store node globally
                        this.state.nodes.set(nodeData.id, {
                            data: nodeData,
                            district: districtData,
                            building: building,
                            worldPosition: new THREE.Vector3()
                        });
                        
                        totalNodes++;
                    });
                    
                    // District label
                    const label = document.createElement('div');
                    label.className = 'district-label';
                    label.textContent = districtData.name.toUpperCase();
                    label.style.color = `#${districtData.color.toString(16).padStart(6, '0')}`;
                    label.dataset.districtId = districtData.id;
                    document.getElementById('ui-layer').appendChild(label);
                    district.userData.labelElement = label;
                    
                    this.scene.add(district);
                    this.state.districts.push(district);
                });
                
                // Update stats
                document.getElementById('stat-districts').textContent = DISTRICTS.length;
                document.getElementById('stat-nodes').textContent = totalNodes;
            },
            
            calculateBuildingPositions(count, radius) {
                const positions = [];
                const innerRadius = radius * 0.6;
                
                if (count === 1) {
                    positions.push({ x: 0, z: 0 });
                } else {
                    for (let i = 0; i < count; i++) {
                        const angle = (i / count) * Math.PI * 2 - Math.PI / 2;
                        const r = innerRadius + (i % 2) * (radius * 0.1);
                        positions.push({
                            x: Math.cos(angle) * r,
                            z: Math.sin(angle) * r
                        });
                    }
                }
                
                return positions;
            },
            
            createBuilding(nodeData, districtData, position) {
                const baseHeight = SCALE_CONFIG.platformRadius * SCALE_CONFIG.heightScale;
                const height = baseHeight * (0.8 + nodeData.importance * 0.4);
                const baseWidth = SCALE_CONFIG.platformRadius * SCALE_CONFIG.buildingScale;
                
                let geometry;
                
                // Type mappings from reference
                const typeMap = {
                    'core': 'core',
                    'storage': 'storage',
                    'processor': 'processor',
                    'transformer': 'transformer',
                    'network': 'network',
                    'ai': 'ai',
                    'monitor': 'processor',
                    'output': 'network',
                    'security': 'core'
                };
                
                const mappedType = typeMap[nodeData.type] || nodeData.type;
                
                switch (mappedType) {
                    case 'core':
                    case 'ai':
                        geometry = new THREE.CylinderGeometry(
                            baseWidth, baseWidth * 1.2, height, 8
                        );
                        break;
                    
                    case 'storage':
                        geometry = new THREE.BoxGeometry(
                            baseWidth * 1.2, height, baseWidth * 1.2
                        );
                        break;
                    
                    case 'processor':
                    case 'transformer':
                        geometry = new THREE.CylinderGeometry(
                            baseWidth * 0.8, baseWidth * 0.8, height, 6
                        );
                        break;
                    
                    case 'network':
                        geometry = new THREE.SphereGeometry(
                            baseWidth * 0.8, 16, 16
                        );
                        break;
                    
                    default:
                        geometry = new THREE.BoxGeometry(
                            baseWidth, height, baseWidth
                        );
                }
                
                const material = new THREE.MeshStandardMaterial({
                    color: 0x2a2a2a,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: districtData.color,
                    emissiveIntensity: 0.05 * nodeData.importance
                });
                
                const building = new THREE.Mesh(geometry, material);
                building.position.set(position.x, 0, position.z);
                building.castShadow = true;
                building.receiveShadow = true;
                
                // Store data
                building.userData = {
                    ...nodeData,
                    height: height,
                    district: districtData.name,
                    districtId: districtData.id
                };
                
                // Add windows
                this.addWindows(building, geometry, districtData.color);
                
                // Add beacon
                const beaconGeometry = new THREE.SphereGeometry(1.5, 8, 6);
                const beaconMaterial = new THREE.MeshBasicMaterial({
                    color: districtData.color,
                    transparent: true,
                    opacity: 0.8
                });
                const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
                beacon.position.y = height / 2 + 3;
                building.add(beacon);
                building.userData.beacon = beacon;
                
                // Edge glow
                const edgeGeometry = new THREE.EdgesGeometry(geometry);
                const edgeMaterial = new THREE.LineBasicMaterial({
                    color: districtData.color,
                    linewidth: 2
                });
                const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                building.add(edges);
                
                return building;
            },
            
            addWindows(building, geometry, color) {
                const windowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6
                });
                
                const windowRows = Math.floor(building.userData.height / 5);
                
                if (geometry.type === 'BoxGeometry') {
                    // Box windows on all 4 sides
                    for (let row = 0; row < windowRows; row++) {
                        const windowGeometry = new THREE.PlaneGeometry(
                            geometry.parameters.width * 0.8, 1
                        );
                        
                        const positions = [
                            { x: 0, z: geometry.parameters.depth/2 + 0.1, ry: 0 },
                            { x: 0, z: -geometry.parameters.depth/2 - 0.1, ry: Math.PI },
                            { x: geometry.parameters.width/2 + 0.1, z: 0, ry: Math.PI/2 },
                            { x: -geometry.parameters.width/2 - 0.1, z: 0, ry: -Math.PI/2 }
                        ];
                        
                        positions.forEach(pos => {
                            const window = new THREE.Mesh(windowGeometry, windowMaterial);
                            window.position.set(
                                pos.x, 
                                5 + row * 5 - building.userData.height/2, 
                                pos.z
                            );
                            window.rotation.y = pos.ry;
                            building.add(window);
                        });
                    }
                } else if (geometry.type === 'CylinderGeometry') {
                    // Cylindrical windows
                    const sides = geometry.parameters.radialSegments || 8;
                    
                    for (let row = 0; row < windowRows; row++) {
                        for (let i = 0; i < sides; i++) {
                            const angle = (i / sides) * Math.PI * 2;
                            const windowGeometry = new THREE.PlaneGeometry(0.8, 1);
                            const window = new THREE.Mesh(windowGeometry, windowMaterial);
                            
                            const radius = (geometry.parameters.radiusTop || geometry.parameters.radius) + 0.1;
                            window.position.set(
                                Math.cos(angle) * radius,
                                5 + row * 5 - building.userData.height/2,
                                Math.sin(angle) * radius
                            );
                            window.lookAt(0, window.position.y, 0);
                            building.add(window);
                        }
                    }
                }
            },
            
            createConnections() {
                const connections = [];
                
                CONNECTIONS.forEach(([fromId, toId]) => {
                    const fromNode = this.state.nodes.get(fromId);
                    const toNode = this.state.nodes.get(toId);
                    
                    if (!fromNode || !toNode) return;
                    
                    // Get world positions
                    const fromDistrict = this.state.districts.find(d => 
                        d.userData.id === fromNode.district.id
                    );
                    const toDistrict = this.state.districts.find(d => 
                        d.userData.id === toNode.district.id
                    );
                    
                    if (!fromDistrict || !toDistrict) return;
                    
                    const fromPos = new THREE.Vector3();
                    fromNode.building.getWorldPosition(fromPos);
                    fromPos.add(fromDistrict.position);
                    fromPos.y = fromNode.building.userData.height + 5;
                    
                    const toPos = new THREE.Vector3();
                    toNode.building.getWorldPosition(toPos);
                    toPos.add(toDistrict.position);
                    toPos.y = toNode.building.userData.height + 5;
                    
                    // Create curved connection
                    const midPoint = new THREE.Vector3(
                        (fromPos.x + toPos.x) / 2,
                        Math.max(fromPos.y, toPos.y) + 10 + Math.random() * 20,
                        (fromPos.z + toPos.z) / 2
                    );
                    
                    const curve = new THREE.CatmullRomCurve3([fromPos, midPoint, toPos]);
                    
                    const tubeGeometry = new THREE.TubeGeometry(curve, 32, 0.3, 8, false);
                    const tubeMaterial = new THREE.MeshStandardMaterial({
                        color: 0x8b5cf6,
                        emissive: 0x8b5cf6,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    this.scene.add(tube);
                    
                    // Add data packets
                    for (let i = 0; i < 3; i++) {
                        const packetGeometry = new THREE.SphereGeometry(0.4, 8, 8);
                        const packetMaterial = new THREE.MeshBasicMaterial({
                            color: 0x00ff88,
                            transparent: true,
                            opacity: 0.8
                        });
                        
                        const packet = new THREE.Mesh(packetGeometry, packetMaterial);
                        packet.userData = {
                            curve: curve,
                            progress: Math.random(),
                            speed: 0.001 + Math.random() * 0.001
                        };
                        
                        this.scene.add(packet);
                        this.state.particles.push(packet);
                    }
                    
                    connections.push({ tube, curve });
                });
                
                this.state.connections = connections;
                document.getElementById('stat-connections').textContent = connections.length;
            },
            
            createParticles() {
                const particleCount = 2000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 300;
                    positions[i * 3 + 1] = Math.random() * 150;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 300;
                    
                    const color = new THREE.Color(
                        DISTRICTS[Math.floor(Math.random() * DISTRICTS.length)].color
                    );
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                    
                    sizes[i] = Math.random() * 2 + 0.5;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        pixelRatio: { value: this.renderer.getPixelRatio() }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 color;
                        varying vec3 vColor;
                        uniform float time;
                        uniform float pixelRatio;
                        
                        void main() {
                            vColor = color;
                            vec3 pos = position;
                            pos.y += sin(time + position.x * 0.01) * 5.0;
                            pos.x += cos(time * 0.5 + position.z * 0.01) * 3.0;
                            
                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            gl_PointSize = size * pixelRatio * (300.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        
                        void main() {
                            float dist = distance(gl_PointCoord, vec2(0.5));
                            if (dist > 0.5) discard;
                            
                            float opacity = 1.0 - smoothstep(0.0, 0.5, dist);
                            gl_FragColor = vec4(vColor, opacity * 0.8);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    vertexColors: true
                });
                
                this.particleSystem = new THREE.Points(geometry, material);
                this.scene.add(this.particleSystem);
            },
            
            setupLighting() {
                // Ambient
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);
                
                // Main directional
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(50, 100, 50);
                dirLight.castShadow = true;
                dirLight.shadow.camera.left = -150;
                dirLight.shadow.camera.right = 150;
                dirLight.shadow.camera.top = 150;
                dirLight.shadow.camera.bottom = -150;
                dirLight.shadow.mapSize.width = 4096;
                dirLight.shadow.mapSize.height = 4096;
                this.scene.add(dirLight);
                
                // Rim light
                const rimLight = new THREE.DirectionalLight(0x8b5cf6, 0.3);
                rimLight.position.set(-50, 50, -50);
                this.scene.add(rimLight);
                
                // District lights
                this.state.districts.forEach(district => {
                    if (district.userData.importance >= 2) {
                        const light = new THREE.PointLight(
                            district.userData.color, 
                            0.5, 
                            100
                        );
                        light.position.copy(district.position);
                        light.position.y = 30;
                        this.scene.add(light);
                    }
                });
            },
            
            handleClick(e) {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.state.buildings);
                
                if (intersects.length > 0) {
                    const building = intersects[0].object;
                    this.dispatchEvent(new CustomEvent('node-select', { 
                        detail: building 
                    }));
                }
            },
            
            handleNodeHover(node) {
                if (this.state.hoveredNode === node) return;
                
                // Reset previous
                if (this.state.hoveredNode) {
                    this.state.hoveredNode.scale.setScalar(1);
                }
                
                this.state.hoveredNode = node;
                
                if (node) {
                    node.scale.setScalar(1.1);
                    document.body.style.cursor = 'pointer';
                    
                    // Show tooltip
                    const tooltip = document.getElementById('node-tooltip');
                    const title = document.getElementById('tooltip-title');
                    const info = document.getElementById('tooltip-info');
                    
                    title.textContent = node.userData.name;
                    info.innerHTML = `
                        Type: ${node.userData.type}<br>
                        District: ${node.userData.district}<br>
                        Importance: ${'★'.repeat(node.userData.importance)}
                    `;
                    
                    const pos = new THREE.Vector3();
                    node.getWorldPosition(pos);
                    pos.project(this.camera);
                    
                    const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                    const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                    
                    tooltip.style.left = x + 'px';
                    tooltip.style.top = y + 'px';
                    tooltip.classList.add('visible');
                } else {
                    document.body.style.cursor = 'default';
                    document.getElementById('node-tooltip').classList.remove('visible');
                }
            },
            
            handleNodeSelect(node) {
                this.state.selectedNode = node;
                
                // Update navigation
                document.getElementById('nav-district').textContent = node.userData.district;
                document.getElementById('nav-node').textContent = node.userData.name;
            },
            
            updateDistrictLabels() {
                this.state.districts.forEach(district => {
                    if (district.userData.labelElement) {
                        const pos = new THREE.Vector3();
                        pos.copy(district.position);
                        pos.y = 10;
                        pos.project(this.camera);
                        
                        if (pos.z < 1) {
                            const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                            
                            district.userData.labelElement.style.left = x + 'px';
                            district.userData.labelElement.style.top = y + 'px';
                            district.userData.labelElement.classList.add('visible');
                        } else {
                            district.userData.labelElement.classList.remove('visible');
                        }
                    }
                });
            },
            
            updateFPS() {
                this.state.frameCount++;
                const currentTime = Date.now();
                
                if (currentTime - this.state.lastTime >= 1000) {
                    this.state.fps = this.state.frameCount;
                    this.state.frameCount = 0;
                    this.state.lastTime = currentTime;
                    
                    document.getElementById('fps-value').textContent = this.state.fps;
                }
            },
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const time = Date.now() * 0.001;
                
                // Update controls
                this.controls.update();
                
                // Check hover
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.state.buildings);
                this.handleNodeHover(intersects.length > 0 ? intersects[0].object : null);
                
                // Animate buildings
                this.state.buildings.forEach((building, i) => {
                    // Subtle sway
                    building.rotation.z = Math.sin(time + i * 0.3) * 0.001;
                    
                    // Beacon pulse
                    if (building.userData.beacon) {
                        const scale = 1 + Math.sin(time * 3 + i) * 0.3;
                        building.userData.beacon.scale.setScalar(scale);
                        building.userData.beacon.material.opacity = 0.6 + Math.sin(time * 3) * 0.2;
                    }
                });
                
                // Central district pulse
                if (this.state.districts[0]) {
                    const scale = 1 + Math.sin(time * 2) * 0.02;
                    this.state.districts[0].scale.set(scale, 1, scale);
                }
                
                // Animate particles
                if (this.particleSystem) {
                    this.particleSystem.material.uniforms.time.value = time;
                    this.particleSystem.rotation.y += 0.0001;
                }
                
                // Animate data packets
                this.state.particles.forEach(packet => {
                    if (packet.userData.curve) {
                        packet.userData.progress += packet.userData.speed;
                        if (packet.userData.progress > 1) {
                            packet.userData.progress = 0;
                        }
                        
                        const point = packet.userData.curve.getPoint(packet.userData.progress);
                        packet.position.copy(point);
                        packet.scale.setScalar(0.8 + Math.sin(time * 10) * 0.2);
                    }
                });
                
                // Update stats
                const dataFlow = Math.floor(100 + Math.sin(time) * 50);
                document.getElementById('stat-flow').textContent = dataFlow + ' TB/s';
                
                // Update labels
                this.updateDistrictLabels();
                
                // Update FPS
                this.updateFPS();
                
                // Render
                this.composer.render();
            }
        });
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            city.init();
        });
    </script>
</body>
</html>