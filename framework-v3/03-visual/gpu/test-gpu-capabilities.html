<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Capabilities Test</title>
    <style>
        body {
            font-family: system-ui;
            background: #0a0a0a;
            color: #fff;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            background: linear-gradient(45deg, #ff0088, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .test-section {
            background: #1a1a1a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .capability {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #333;
        }
        .capability:last-child {
            border-bottom: none;
        }
        .supported { color: #00ff88; }
        .unsupported { color: #ff0044; }
        .partial { color: #ffaa00; }
        pre {
            background: #000;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
        }
        canvas {
            border: 1px solid #333;
            margin: 10px 0;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ® GPU Capabilities Test</h1>
        
        <div class="test-section">
            <h2>GPU Detection Results</h2>
            <div id="gpuResults"></div>
        </div>

        <div class="test-section">
            <h2>WebGPU Capabilities</h2>
            <div id="webgpuResults"></div>
            <canvas id="webgpuCanvas" width="400" height="200"></canvas>
        </div>

        <div class="test-section">
            <h2>WebGL2 Capabilities</h2>
            <div id="webgl2Results"></div>
            <canvas id="webgl2Canvas" width="400" height="200"></canvas>
        </div>

        <div class="test-section">
            <h2>Performance Tests</h2>
            <div id="perfResults"></div>
        </div>
    </div>

    <script>
        // GPU Detection
        async function detectGPUCapabilities() {
            const results = document.getElementById('gpuResults');
            const capabilities = [];

            // Check WebGPU
            if ('gpu' in navigator) {
                try {
                    const adapter = await navigator.gpu.requestAdapter();
                    if (adapter) {
                        const device = await adapter.requestDevice();
                        capabilities.push({
                            name: 'WebGPU',
                            status: 'supported',
                            details: 'Full support'
                        });

                        // Get WebGPU limits
                        const limits = device.limits;
                        capabilities.push({
                            name: 'Max Texture Size',
                            status: 'info',
                            details: `${limits.maxTextureDimension2D}x${limits.maxTextureDimension2D}`
                        });
                        capabilities.push({
                            name: 'Max Buffer Size',
                            status: 'info',
                            details: `${(limits.maxBufferSize / 1024 / 1024).toFixed(2)} MB`
                        });
                        capabilities.push({
                            name: 'Max Compute Workgroups',
                            status: 'info',
                            details: `${limits.maxComputeWorkgroupsPerDimension}`
                        });

                        await testWebGPU(device);
                    } else {
                        capabilities.push({
                            name: 'WebGPU',
                            status: 'unsupported',
                            details: 'No adapter available'
                        });
                    }
                } catch (e) {
                    capabilities.push({
                        name: 'WebGPU',
                        status: 'unsupported',
                        details: e.message
                    });
                }
            } else {
                capabilities.push({
                    name: 'WebGPU',
                    status: 'unsupported',
                    details: 'Not available in navigator'
                });
            }

            // Check WebGL2
            const canvas = document.createElement('canvas');
            const gl2 = canvas.getContext('webgl2');
            if (gl2) {
                capabilities.push({
                    name: 'WebGL2',
                    status: 'supported',
                    details: 'Full support'
                });

                // Get WebGL2 capabilities
                capabilities.push({
                    name: 'Max Texture Size',
                    status: 'info',
                    details: `${gl2.getParameter(gl2.MAX_TEXTURE_SIZE)}x${gl2.getParameter(gl2.MAX_TEXTURE_SIZE)}`
                });
                capabilities.push({
                    name: 'Max Vertex Attributes',
                    status: 'info',
                    details: gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS)
                });
                capabilities.push({
                    name: 'Max Texture Units',
                    status: 'info',
                    details: gl2.getParameter(gl2.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
                });

                // Check extensions
                const extensions = gl2.getSupportedExtensions();
                const importantExts = [
                    'EXT_color_buffer_float',
                    'OES_texture_float_linear',
                    'WEBGL_compute_shader'
                ];
                
                importantExts.forEach(ext => {
                    capabilities.push({
                        name: `Extension: ${ext}`,
                        status: extensions.includes(ext) ? 'supported' : 'unsupported',
                        details: ''
                    });
                });

                await testWebGL2();
            } else {
                capabilities.push({
                    name: 'WebGL2',
                    status: 'unsupported',
                    details: 'Context creation failed'
                });
            }

            // Check WebGL1 fallback
            const gl1 = canvas.getContext('webgl');
            capabilities.push({
                name: 'WebGL1',
                status: gl1 ? 'supported' : 'unsupported',
                details: gl1 ? 'Available as fallback' : 'Not available'
            });

            // Check OffscreenCanvas
            capabilities.push({
                name: 'OffscreenCanvas',
                status: typeof OffscreenCanvas !== 'undefined' ? 'supported' : 'unsupported',
                details: typeof OffscreenCanvas !== 'undefined' ? 'Available for workers' : 'Not available'
            });

            // GPU Info
            if (gl2) {
                const debugInfo = gl2.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    capabilities.push({
                        name: 'GPU Vendor',
                        status: 'info',
                        details: gl2.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL)
                    });
                    capabilities.push({
                        name: 'GPU Renderer',
                        status: 'info',
                        details: gl2.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                    });
                }
            }

            // Display results
            results.innerHTML = capabilities.map(cap => `
                <div class="capability">
                    <span>${cap.name}:</span>
                    <span class="${cap.status}">${cap.details || cap.status}</span>
                </div>
            `).join('');
        }

        // Test WebGPU
        async function testWebGPU(device) {
            const canvas = document.getElementById('webgpuCanvas');
            const context = canvas.getContext('webgpu');
            
            if (!context) {
                document.getElementById('webgpuResults').innerHTML = 
                    '<p class="unsupported">WebGPU context not available</p>';
                return;
            }

            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format,
                alphaMode: 'premultiplied',
            });

            // Create shader module
            const shaderCode = `
                struct VertexOutput {
                    @builtin(position) position: vec4<f32>,
                    @location(0) color: vec4<f32>,
                };

                @vertex
                fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
                    var pos = array<vec2<f32>, 3>(
                        vec2<f32>( 0.0,  0.5),
                        vec2<f32>(-0.5, -0.5),
                        vec2<f32>( 0.5, -0.5)
                    );
                    var colors = array<vec4<f32>, 3>(
                        vec4<f32>(1.0, 0.0, 0.0, 1.0),
                        vec4<f32>(0.0, 1.0, 0.0, 1.0),
                        vec4<f32>(0.0, 0.0, 1.0, 1.0)
                    );

                    var output: VertexOutput;
                    output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                    output.color = colors[vertexIndex];
                    return output;
                }

                @fragment
                fn fs_main(@location(0) color: vec4<f32>) -> @location(0) vec4<f32> {
                    return color;
                }
            `;

            const shaderModule = device.createShaderModule({
                code: shaderCode
            });

            // Create pipeline
            const pipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vs_main',
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fs_main',
                    targets: [{
                        format: format,
                    }],
                },
                primitive: {
                    topology: 'triangle-list',
                },
            });

            // Render
            const commandEncoder = device.createCommandEncoder();
            const textureView = context.getCurrentTexture().createView();

            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: textureView,
                    clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }],
            });

            renderPass.setPipeline(pipeline);
            renderPass.draw(3);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);

            document.getElementById('webgpuResults').innerHTML = 
                '<p class="supported">WebGPU rendering successful!</p>';
        }

        // Test WebGL2
        async function testWebGL2() {
            const canvas = document.getElementById('webgl2Canvas');
            const gl = canvas.getContext('webgl2');

            if (!gl) {
                document.getElementById('webgl2Results').innerHTML = 
                    '<p class="unsupported">WebGL2 context not available</p>';
                return;
            }

            // Vertex shader
            const vsSource = `#version 300 es
                in vec2 position;
                in vec3 color;
                out vec3 vColor;
                
                void main() {
                    gl_Position = vec4(position, 0.0, 1.0);
                    vColor = color;
                }
            `;

            // Fragment shader
            const fsSource = `#version 300 es
                precision highp float;
                in vec3 vColor;
                out vec4 fragColor;
                
                void main() {
                    fragColor = vec4(vColor, 1.0);
                }
            `;

            // Compile shaders
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link failed:', gl.getProgramInfoLog(program));
                return;
            }

            // Triangle data
            const positions = new Float32Array([
                 0.0,  0.5,
                -0.5, -0.5,
                 0.5, -0.5
            ]);

            const colors = new Float32Array([
                1.0, 0.0, 0.0,
                0.0, 1.0, 0.0,
                0.0, 0.0, 1.0
            ]);

            // Create buffers
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

            // Setup attributes
            const positionLoc = gl.getAttribLocation(program, 'position');
            const colorLoc = gl.getAttribLocation(program, 'color');

            // Create VAO
            const vao = gl.createVertexArray();
            gl.bindVertexArray(vao);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

            // Render
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.bindVertexArray(vao);
            gl.drawArrays(gl.TRIANGLES, 0, 3);

            document.getElementById('webgl2Results').innerHTML = 
                '<p class="supported">WebGL2 rendering successful!</p>';

            // Run performance test
            await runPerformanceTests(gl);
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile failed:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Performance tests
        async function runPerformanceTests(gl) {
            const results = document.getElementById('perfResults');
            const tests = [];

            // Test 1: Triangle throughput
            const triangleCount = 100000;
            const vertices = new Float32Array(triangleCount * 9); // 3 vertices * 3 coords
            for (let i = 0; i < vertices.length; i++) {
                vertices[i] = (Math.random() - 0.5) * 2;
            }

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const start = performance.now();
            for (let i = 0; i < 100; i++) {
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, triangleCount * 3);
            }
            gl.finish();
            const duration = performance.now() - start;

            tests.push({
                name: 'Triangle Throughput',
                result: `${(triangleCount * 100 / duration * 1000).toFixed(0)} triangles/sec`
            });

            // Test 2: Texture upload speed
            const textureSize = 1024;
            const textureData = new Uint8Array(textureSize * textureSize * 4);
            for (let i = 0; i < textureData.length; i++) {
                textureData[i] = Math.random() * 255;
            }

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);

            const uploadStart = performance.now();
            for (let i = 0; i < 10; i++) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureSize, 0, 
                    gl.RGBA, gl.UNSIGNED_BYTE, textureData);
            }
            const uploadDuration = performance.now() - uploadStart;

            tests.push({
                name: 'Texture Upload',
                result: `${(textureSize * textureSize * 4 * 10 / uploadDuration / 1024 / 1024 * 1000).toFixed(2)} MB/s`
            });

            // Display results
            results.innerHTML = tests.map(test => `
                <div class="capability">
                    <span>${test.name}:</span>
                    <span class="supported">${test.result}</span>
                </div>
            `).join('');
        }

        // Run tests
        detectGPUCapabilities();
    </script>
</body>
</html>